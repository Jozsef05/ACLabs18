#include <MovingAverageFilter.h>

#include <boarddefs.h>
#include <IRremote.h>
#include <IRremoteInt.h>
#include <ir_Lego_PF_BitStreamEncoder.h>

#include "Types.h"
#include "Motors.h"
#include "Ultrasonic.h"

IRrecv irrecv(2);
IRsend irsend;
decode_results results;

MovingAverageFilter senzor_fwd(100);
MovingAverageFilter senzor_left(100);
MovingAverageFilter senzor_right(100);
 
NewPing sonar1(trig_1, echo_1, Max_Dist); 
NewPing sonar2(trig_2, echo_2, Max_Dist); 
NewPing sonar3(trig_3, echo_3, Max_Dist);
int snr3_fwd;
int snr2_right;
int snr1_left;
uint32 value=0;
int state=0;
int val_speed_left;
int val_speed_right;
int blue=39;
int red=41;
int green=43;
uint32 timeLed = millis();
int continua=0;
int previous_fwd;
int previous_left;
int previous_right;
int k;
uint8 flagStop =0;
uint32 timer_spate;
uint32 time_left_turn;
uint32 time_right_turn;
uint32 timestate;
int suma=0;
int temp=25;
void setup() {
    irrecv.enableIRIn(); 
    
    pingTimer1 = millis() + pingSpeed; // Sensor 1 fires after 1 second (pingSpeed)
    pingTimer2 = pingTimer1 + delay_ping; // Sensor 2 fires 35ms later
    pingTimer3 = pingTimer2 + delay_ping;
    delay(5000);
    
Serial.begin(9600);
}

void loop() {
	
	//make the led go blink blink!  requirement SYSS_31
	if((millis()-timeLed<200)&& flagStop==0){
		digitalWrite(red,40);
    digitalWrite(blue,40);
	}
	else{
		digitalWrite(red,LOW);
    digitalWrite(blue,LOW);
    }
    if(millis()-timeLed>400)
		timeLed = millis();
   
  //irsend.sendSony(0xa90, 12);
    
    //corectii pentru distante prea mari cand da sonaru 0
    previous_fwd=25;
    temp=snr3_fwd;
    snr3_fwd=senzor_fwd.process(sonar3.ping_cm()); 
    
    
	if(0==snr3_fwd ){
		snr3_fwd=previous_fwd;
    }//else if (snr3_fwd>previous_fwd){
       //snr3_fwd=pre
      //}
  if(temp-snr3_fwd>10){
      snr3_fwd=temp;
    }
    previous_left=snr1_left;
    snr1_left=senzor_left.process(sonar1.ping_cm());
    
	if(0==snr1_left){
		snr1_left=previous_left;
    }
    
	previous_right=snr2_right;
	snr2_right=senzor_right.process(sonar2.ping_cm());
	if(0==snr2_right){
		snr2_right=previous_right;
    } 
  // k=snr1_left-snr2_right;     //daca robotul vireaza pe o un drum drept distantele st-dr vor varia
 //if (k>8)       // corectie ca k sa nu devina prea mare cand facem un viraj la dreapta sau gasim o cale spre stanga
 // k=0;           //
 //else if (k<-8) //
 // k=0;           //
 
   k=10;
   val_speed_right=150+k*(6-snr2_right);   
   val_speed_left=150;       

    if ((irrecv.decode(&results)))
         {
           irrecv.resume();  
           value= results.value;
           Serial.println(value);
          
         }

 
           if(results.value==4294967295 || (flagStop))
            {  
              flagStop = 1;
              go(0,0,0);
              
              digitalWrite(red,HIGH);
              digitalWrite(blue,LOW);
              digitalWrite(green,HIGH);
              Serial.println(value);
              Serial.println(flagStop);
              analogWrite(MOTOR_Left_1,250);
              analogWrite(MOTOR_Right_1,0);// motor 1;
              analogWrite(MOTOR_Left_2,0); //motor 2;
              analogWrite(MOTOR_Right_2,250);
              
            }
           else
   {
   
   switch(state){ // requirement SYSS_32
      case 0:
            go(0,0,0);
      if(snr3_fwd>25 && snr2_right<15){
            state=1;
           }
		   else if(snr2_right>15){
             time_right_turn=millis();
             state=2;
            }
			else if(snr3_fwd<15 && snr1_left>15 && snr2_right<15){
        time_left_turn=millis();
        state=3;
        } 
            
      break;
	  
      case 1:
      timestate = millis();
      Serial.print("STARE 1 :");
      Serial.println(snr3_fwd);
      if(snr3_fwd>25 && snr2_right<15)
         go(val_speed_left,val_speed_right,1);  
      else if(snr2_right>24){
        time_right_turn=millis();
        state=2;
        }
      else if(snr3_fwd<20 && snr1_left>12 && snr2_right<15){
        time_left_turn=millis();
        Serial.println(snr3_fwd);
        state=3;
      }
	  else if((snr3_fwd<15 && snr3_fwd>4 )&& (snr1_left<15 && snr2_right<15)){
        state=4;
        }
      break;
      
	  case 2:
      Serial.println("STARE 2");
      
       /*if(millis()-time_right_turn<950) {
         go(200,40,1); 
      }else
        state=1;
        */
        if(snr2_right>15)
        go(150,40,1);
        else
        state=1;
      
      break;
      
      case 3:
      Serial.print("STARE 3 :");
      Serial.println(snr3_fwd);
      Serial.println(snr1_left);
      Serial.println(snr2_right);
      
       if(millis()-time_left_turn<1175) {
         go(30,150,1); 
      }else
        state=1;
	  break;
	    
      case 4:
      
        /*timer_spate++;
        
        Serial.println("STARE 4");
        go(150,150,0);
        if(timer_spate==1000){
          Serial.println("IF 1000 ");
          state=3;
          }else{
            state=1;
            }*/
Serial.println("STARE 4");
      if(millis()-timestate<1100) {
      analogWrite(MOTOR_Left_1,150);
      analogWrite(MOTOR_Right_1,0);// motor 1;
      analogWrite(MOTOR_Left_2,0); //motor 2;
      analogWrite(MOTOR_Right_2,150);
      }
      else
      state=1;
   
      break;
   } 
}
}
void go(int vit1,int vit2,int direct){ // direct=1 fata,0 spate
    if(direct){
      analogWrite(MOTOR_Left_1,0);
      analogWrite(MOTOR_Right_1,vit1);// motor 1;
      analogWrite(MOTOR_Left_2,0); //motor 2;
      analogWrite(MOTOR_Right_2,vit2);
    }
    else{
      analogWrite(MOTOR_Left_1,vit1);
      analogWrite(MOTOR_Right_1,0);// motor 1;
      analogWrite(MOTOR_Left_2,vit2); //motor 2;
      analogWrite(MOTOR_Right_2,0); 
      }
  }


 
